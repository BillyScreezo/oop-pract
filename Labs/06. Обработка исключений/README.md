# Лабораторная работа 6: Обработка исключений

## Теоретическая часть

Ошибки в программах можно разделить на два типа:
- **Ошибки времени компиляции** – возникают при компиляции программы, например, из-за синтаксических ошибок.
- **Ошибки времени выполнения** – возникают в процессе работы программы, например, при некорректном вводе данных пользователем.

Одним из способов обработки ошибок времени выполнения являются **исключения**. Исключения позволяют избежать аварийного завершения программы, передавая управление специальным обработчикам ошибок.

### `try` и `catch`

Для перехвата и обработки исключений применяется конструкция `try` - `catch`. Блок кода, в котором может возникнуть ошибка, заключается в `try`. Если внутри него возникает исключение, выполнение передается в соответствующий `catch`-блок.

Пример:
```cpp
#include <iostream>
#include <string>

int main() {
    std::string str;
    std::cin >> str;

    try {
        int year = std::stoi(str);
        std::cout << "Введенный год: " << year << std::endl;
    }
    catch (const std::invalid_argument& ex) {
        std::cout << "Недопустимое число: " << ex.what() << std::endl;
    }
    catch (const std::out_of_range& ex) {
        std::cout << "Число выходит за пределы допустимого диапазона: " << ex.what() << std::endl;
    }
    
    return 0;
}
```

В этом примере, если пользователь введет некорректное число, `std::stoi` выбросит исключение, и выполнение перейдет в `catch`-блок.

### `throw`

Для генерации исключений используется оператор `throw`. Можно выбрасывать исключения различных типов:
```cpp
throw 5;                                        // Целочисленное исключение
throw std::string("Ошибка!");                   // Исключение строкового типа
throw std::runtime_error("Ошибка выполнения!"); // Исключение runtime
```

Пример с проверкой корректности введенного года:
```cpp
int year;
std::cin >> year;
if (year < 1905 || year > 2030) {
    throw std::invalid_argument("Введен неправильный год");
}
```

### `std::exception` и его производные

В стандартной библиотеке C++ определен базовый класс исключений `std::exception`, от которого наследуются другие типы исключений, такие как:
- `std::runtime_error` – ошибки времени выполнения
- `std::logic_error` – ошибки логики программы
- `std::invalid_argument` – некорректные аргументы функций
- `std::out_of_range` – выход за допустимый диапазон
- `std::bad_alloc` – ошибка выделения памяти

Этот класс определяет виртуальный метод `what()`, который возвращает строковое описание ошибки:
```cpp
try {
    throw std::runtime_error("Ошибка в программе");
}
catch (const std::exception& ex) {
    std::cout << "Исключение: " << ex.what() << std::endl;
}
```

### Почему переопределяют `what()`

Метод `what()` часто переопределяют в пользовательских классах исключений, чтобы передавать более подробную информацию об ошибке. Например:
```cpp
#include <exception>
#include <string>

class FileOpenException : public std::exception {
private:
    std::string message;
public:
    FileOpenException(const std::string& filename)
        : message("Не удалось открыть файл: " + filename) {}
    const char* what() const noexcept override {
        return message.c_str();
    }
};
```

Теперь можно выбрасывать и перехватывать `FileOpenException`:
```cpp
#include <iostream>
#include <fstream>

void openFile(const std::string& filename) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        throw FileOpenException(filename);
    }
}

int main() {
    try {
        openFile("nonexistent.txt");
    }
    catch (const std::exception& ex) {
        std::cout << "Ошибка: " << ex.what() << std::endl;
    }
    return 0;
}
```

### Обработка нескольких типов исключений
Можно перехватывать разные типы исключений, используя несколько `catch`-блоков:
```cpp
try {
    throw std::runtime_error("Что-то пошло не так");
}
catch (const std::invalid_argument& ex) {
    std::cout << "Ошибка аргумента: " << ex.what() << std::endl;
}
catch (const std::exception& ex) {
    std::cout << "Общая ошибка: " << ex.what() << std::endl;
}
catch (...) {
    std::cout << "Неизвестная ошибка" << std::endl;
}
```
Последний `catch (...)` перехватывает любые исключения, если их тип не был явно указан в предыдущих блоках.

### Раскручивание стека

Если исключение, выработанное в текущей исполняемой функции, не было перехвачено в этой функции (`catch` отсутствует или не соответствует типу исключения), программа начинает так называемое **раскручивание стека**: 
- Выполнение выходит из текущей функции и переходит к вызывающей.
- Если в вызывающей функции тоже нет подходящего `catch`, выход продолжается по стеку вызовов.
- Если в конечном итоге исключение не будет обработано, программа аварийно завершится, часто с сообщением о необработанном исключении.

Пример:
```cpp
void foo() {
    throw std::runtime_error("Ошибка в foo");
}

void bar() {
    foo(); // Исключение не обрабатывается здесь
}

int main() {
    bar(); // Исключение "поднимается" сюда и завершает программу
    return 0;
}
```
В этом коде исключение поднимается по стеку от `foo()` → `bar()` → `main()`, так как нигде не было `catch`, и программа аварийно завершается.

## Практическое задание

1) **Модифицировать CsvReader**:
   - Завернуть вызовы `std::stoi` в `try` - `catch`, чтобы при ошибках в CSV-файле программа не падала, а выводила сообщение и продолжала работать.
   
2) **Создать собственный класс исключения**:
   - Разработать класс `CsvParseException`, наследованный от `std::exception`.
   - Исключение должно хранить текстовое описание ошибки и номер строки, где она произошла.
   - Использовать `throw CsvParseException` в `CsvReader` при ошибках в `std::stoi`.

3) **Добавить обработку исключений в `MainWindow`**:
   - Перехватывать `CsvParseException` при вызове `CsvReader::readAll()`.
   - Выводить сообщение об ошибке и номер строки в `textBrowser` красным цветом.

Пример обработки в `MainWindow`:
```cpp
try {
    csvReader.readAll();
}
catch (const CsvParseException& ex) {
    textBrowser->setTextColor(Qt::red);
    textBrowser->append("Ошибка в строке " + QString::number(ex.getLineNumber()) + ": " + ex.what());
}
```