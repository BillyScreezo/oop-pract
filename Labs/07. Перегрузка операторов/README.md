# Лабораторная работа 7: Перегрузка операторов

## Теоретическая часть

Перегрузка операторов в C++ позволяет переопределить стандартное поведение операторов для пользовательских типов данных. Это улучшает читаемость кода и делает объекты более интуитивными в использовании.

### Основные принципы перегрузки
1. **Перегрузка выполняется с использованием методов класса или дружественных функций.**
2. **Не все операторы можно перегружать.** Например, нельзя перегружать `.` (точка), `::` (разрешение области видимости) и `sizeof`.
3. **Перегруженные операторы должны сохранять семантику оригинальных операторов.**
4. **Перегрузка может выполняться как методом класса или внешней функцией.** Операторы, изменяющие объект (`+=`, `-=`, `++`, `--`), должны быть методами класса.
5. **Операторы `<<` и `>>` должны быть дружественными функциями.** Это необходимо, так как левый операнд (`std::ostream` или `std::istream`) не является объектом пользовательского класса.

### Пример перегрузки операторов

Рассмотрим класс `Complex` для работы с комплексными числами.

```cpp
#include <iostream>

// Комплексное число
class Complex {
private:
    // Действительная и мнимая части комплексного числа
    double real, imag;

public:
    // Конструктор класса
    Complex(double real = 0, double imag = 0) : real(real), imag(imag) {}

    // Перегрузка оператора + через метод класса
    Complex operator+(const Complex& other) const {
        return Complex(real + other.real, imag + other.imag);
    }

    // Перегрузка оператора - через метод класса
    Complex operator-(const Complex& other) const {
        return Complex(real - other.real, imag - other.imag);
    }

    // Перегрузка оператора * для умножения комплексных чисел
    Complex operator*(const Complex& other) const {
        return Complex(real * other.real - imag * other.imag, real * other.imag + imag * other.real);
    }

    // Перегрузка оператора == через метод класса
    bool operator==(const Complex& other) const {
        return real == other.real && imag == other.imag;
    }

    // Перегрузка оператора << через дружественную функцию
    friend std::ostream& operator<<(std::ostream& os, const Complex& c) {
        os << c.real << " + " << c.imag << "i";
        return os;
    }
};

int main() {
    Complex c1(2, 3), c2(1, 4);
    std::cout << "c1: " << c1 << "\nc2: " << c2 << "\n";
    std::cout << "c1 + c2: " << (c1 + c2) << "\n";
    std::cout << "c1 - c2: " << (c1 - c2) << "\n";
    std::cout << "c1 * c2: " << (c1 * c2) << "\n";
    std::cout << "c1 == c2: " << (c1 == c2) << "\n";
}
```

## Задания

### Основное задание

Разработайте класс по вашему варианту и перегрузите указанные операторы.

1) **Двумерный вектор (`Vec2d`)**
   - Координаты `x`, `y`
   - Операторы: `+`, `-`, `<`, `>`, `*` (умножение на число), `<<`

2) **Прямоугольник (`Rect`)**
   - Ширина `w`, высота `h`
   - Операторы: `+`, `-`, `+=`, `++` (постфиксный), `/` (деление на число), `<<`

3) **Вектор в полярных координатах (`VecPolar`)**
   - Длина `L`, угол `phi`
   - Операторы: `+`, `-`, `*` (умножение на число), `<`, `>`, `<<`

4) **Цвет в палитре RGB (`ColorRgb`)**
   - Компоненты `r`, `g`, `b`
   - Операторы: `+`, `-`, `-=`, `*` (умножение на число), `++`, `<<`

### Дополнительные задания
1. Перегрузите оператор `==` для всех классов.
2. Перегрузите оператор `!=` для всех классов.
3. Добавьте оператор `*=` (умножение на число) в `Vec2d`, `VecPolar` и `ColorRgb`.
4. Реализуйте оператор `--` (постфиксный) в `ColorRgb` (уменьшение насыщенности цвета).
5. Реализуйте оператор `+=` для всех классов.
6. Добавьте оператор `[]` для доступа к отдельным компонентам в `Vec2d` и `ColorRgb`.

## Вывод
Перегрузка операторов позволяет работать с пользовательскими классами так же удобно, как со встроенными типами, улучшая читаемость кода. Важно соблюдать семантику операций и не перегружать операторы так, чтобы их поведение было неожиданным.

